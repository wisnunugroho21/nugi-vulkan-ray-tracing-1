#version 460

// ------------- layout -------------

#define SHININESS 64
#define KEPSILON 0.00001

#include "core/struct.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(set = 0, binding = 0, rgba8) uniform writeonly image2D targetImage;

layout(set = 0, binding = 1) uniform readonly GlobalUbo {
  vec4 origin;
  vec4 horizontal;
  vec4 vertical;
  vec4 lowerLeftCorner;
  vec4 background;
} ubo;

layout(set = 0, binding = 2) buffer readonly ObjectSsbo {
  Object objects[100];
};

layout(set = 0, binding = 3) buffer readonly ObjectBvhSsbo {
  BvhNode objectBvhNodes[100];
};

layout(set = 0, binding = 4) buffer readonly PrimitiveSsbo {
  Primitive primitives[100];
};

layout(set = 0, binding = 5) buffer readonly PrimitiveBvhSsbo {
  BvhNode primitiveBvhNodes[100];
};

layout(set = 0, binding = 6) buffer readonly LightSsbo {
  Light lights[100];
};

layout(set = 0, binding = 7) buffer readonly LightBvhSsbo {
  BvhNode lightBvhNodes[100];
};

layout(set = 0, binding = 8) buffer readonly MaterialSsbo {
  Material materials[100];
};

layout(set = 0, binding = 9) buffer readonly TransformationSsbo {
  Transformation transformations[100];
};

layout(push_constant) uniform Push {
  uint randomSeed;
} push;

uvec2 imgSize = uvec2(imageSize(targetImage));

#include "core/random.glsl"
#include "core/trace.glsl"
#include "core/ggx.glsl"
#include "core/shape.glsl"
#include "core/material.glsl"
#include "core/render.glsl"

// ------------- Material -------------

ShadeRecord indirectGgxShade(Ray r, HitRecord hit, int materialIndex, uint additionalRandomSeed) {
  ShadeRecord scat;
  scat.raySpecular.origin = hit.point;

  vec4 unitViewDirection = normalize(r.direction);
  float f0 = 0.16 * (materials[materialIndex].fresnelReflect * materials[materialIndex].fresnelReflect);

  vec4[3] globalOnb = buildOnb(reflect(unitViewDirection, hit.faceNormal.normal));
  scat.raySpecular.direction = ggxGenerateRandom(globalOnb, materials[materialIndex].roughness, additionalRandomSeed);

  vec4 H = normalize(scat.raySpecular.direction - r.direction); // half vector

  float NoL = max(dot(hit.faceNormal.normal, normalize(scat.raySpecular.direction)), 0.001);
  float NoV = max(dot(hit.faceNormal.normal, -1.0 * unitViewDirection), 0.001);
  float NoH = max(dot(hit.faceNormal.normal, H), 0.001);
  float VoH = max(dot(unitViewDirection, H), 0.001);

  float brdf = ggxBrdfValue(NoV, NoL, NoH, VoH, f0, materials[materialIndex].roughness);

  scat.pdf = ggxPdfValue(NoH, NoL, materials[materialIndex].roughness);
  scat.colorAttenuation = partialIntegrand(materials[materialIndex].baseColor, brdf, NoL);
  
  return scat;
}

ShadeRecord indirectLambertShade(Ray r, HitRecord hit, int materialIndex, uint additionalRandomSeed) {
  ShadeRecord scat;
  scat.raySpecular.origin = hit.point;

  if (randomInt(0, 1, 0, additionalRandomSeed) == 0) {
    int triangleRand = (randomInt(0, 1, 1, additionalRandomSeed) + randomInt(0, 1, 2, additionalRandomSeed)) % 2;
    scat.raySpecular.direction = triangleGenerateRandom(lights[triangleRand].triangle, hit.point, additionalRandomSeed);
  } else {
    vec4[3] globalOnb = buildOnb(hit.faceNormal.normal);
    scat.raySpecular.direction = lambertGenerateRandom(globalOnb, additionalRandomSeed);
  }

  float NoL = max(dot(hit.faceNormal.normal, normalize(scat.raySpecular.direction)), 0.001);
  float brdf = lambertBrdfValue();

  scat.pdf = lambertPdfValue(NoL);
  scat.colorAttenuation = partialIntegrand(materials[materialIndex].baseColor, brdf, NoL); 
  
  return scat;
}

ShadeRecord directGgxShade(Ray r, HitRecord hit, int materialIndex, uint additionalRandomSeed) {
  ShadeRecord scat;
  Ray shadowRay;

  scat.colorAttenuation = vec4(0.0);
  scat.pdf = 0.0;

  shadowRay.origin = hit.point;
  int lightIndex = (randomInt(0, 1, 1, additionalRandomSeed) + randomInt(0, 1, 2, additionalRandomSeed)) % 2;

  shadowRay.direction = triangleGenerateRandom(lights[lightIndex].triangle, hit.point, additionalRandomSeed);
  HitRecord occludedHit = hitObjectBvh(shadowRay, 0.001, 1000000.0);

  if (!occludedHit.isHit) {
    vec4 unitLightDirection = normalize(shadowRay.direction);
    FaceNormal hittedLightFaceNormal = triangleFaceNormal(lights[lightIndex].triangle, unitLightDirection);

    float NloL = max(dot(hittedLightFaceNormal.normal, -1.0 * unitLightDirection), 0.001);
    float NoL = max(dot(hit.faceNormal.normal, unitLightDirection), 0.001);    

    vec4 unitViewDirection = normalize(r.direction);
    vec4 H = normalize(shadowRay.direction - r.direction); // half vector

    float f0 = 0.16 * (materials[materialIndex].fresnelReflect * materials[materialIndex].fresnelReflect);
    
    float NoV = max(dot(hit.faceNormal.normal, -1.0 * unitViewDirection), 0.001);
    float NoH = max(dot(hit.faceNormal.normal, H), 0.001);
    float VoH = max(dot(unitViewDirection, H), 0.001);

    float brdf = ggxBrdfValue(NoV, NoL, NoH, VoH, f0, materials[materialIndex].roughness);
    float sqrDistance = dot(shadowRay.direction, shadowRay.direction);
    float area = areaTriangle(lights[lightIndex].triangle);

    scat.pdf = ggxPdfValue(NoH, NoL, materials[materialIndex].roughness);
    scat.colorAttenuation = partialIntegrand(materials[materialIndex].baseColor, brdf, NoL) * Gfactor(NloL, sqrDistance, area) * lights[lightIndex].color;
  }  

  return scat;
}

ShadeRecord directLambertShade(Ray r, HitRecord hit, int materialIndex, uint additionalRandomSeed) {
  ShadeRecord scat;
  Ray shadowRay;

  scat.colorAttenuation = vec4(0.0);
  scat.pdf = 0.0;

  shadowRay.origin = hit.point;
  int lightIndex = (randomInt(0, 1, 1, additionalRandomSeed) + randomInt(0, 1, 2, additionalRandomSeed)) % 2;

  shadowRay.direction = triangleGenerateRandom(lights[lightIndex].triangle, hit.point, additionalRandomSeed);
  HitRecord occludedHit = hitObjectBvh(shadowRay, 0.001, 1000000.0);

  if (!occludedHit.isHit) {
    vec4 unitLightDirection = normalize(shadowRay.direction);
    FaceNormal hittedLightFaceNormal = triangleFaceNormal(lights[lightIndex].triangle, unitLightDirection);

    float NloL = max(dot(hittedLightFaceNormal.normal, -1.0 * unitLightDirection), 0.001);
    float NoL = max(dot(hit.faceNormal.normal, unitLightDirection), 0.001);    

    float sqrDistance = dot(shadowRay.direction, shadowRay.direction);
    float area = areaTriangle(lights[lightIndex].triangle);
    float brdf = lambertBrdfValue();

    scat.pdf = lambertPdfValue(NoL);
    scat.colorAttenuation = partialIntegrand(materials[materialIndex].baseColor, brdf, NoL) * Gfactor(NloL, sqrDistance, area) * lights[lightIndex].color;
  }  

  return scat;
}

// ------------- Main -------------

void main() {
  uvec2 imgPosition = gl_GlobalInvocationID.xy;

  float noiseX = randomFloat(1, 0) * 2.0 - 1.0;
  float noiseY = randomFloat(2, 0) * 2.0 - 1.0;

  vec2 noiseUV = vec2(noiseX, noiseY);
  vec2 uv = (imgPosition + noiseUV) / imgSize;

  vec4 totalAttenuation = vec4(0.0);
  vec4 totalIndirect = vec4(1.0);

  ShadeRecord indirectScat, directScat;
  Ray curRay;

  indirectScat.pdf = 1.0;
  curRay.origin = ubo.origin;
  curRay.direction = ubo.lowerLeftCorner + uv.x * ubo.horizontal - uv.y * ubo.vertical - ubo.origin;
  
  for(uint i = 0; i < 3; i++) {
    HitRecord hit = hitObjectBvh(curRay, 0.001, 1000000.0);
    if (!hit.isHit) {
      totalAttenuation = totalAttenuation + totalIndirect * ubo.background;
      break;
    }

    HitRecord hittedLight = hitLightBvh(curRay, 0.001, hit.t);
    if (hittedLight.isHit) {
      if (i > 0) {
        totalIndirect = totalIndirect * Gfactor(curRay, hittedLight, hittedLight.hitPrimIndex);
      }

      totalAttenuation = totalAttenuation + totalIndirect * lights[hittedLight.hitPrimIndex].color;
      break;
    }

    totalIndirect = totalIndirect / indirectScat.pdf;

    int transformIndex = objects[hit.hitObjIndex].transformIndex;
    int materialIndex = primitives[hit.hitPrimIndex].materialIndex;

    if (materials[materialIndex].metallicness >= randomFloat(0, i)) {
      indirectScat = indirectGgxShade(curRay, hit, materialIndex, i);
      directScat = directGgxShade(curRay, hit, materialIndex, i);
    } else {
      indirectScat = indirectLambertShade(curRay, hit, materialIndex, i);
      directScat = directLambertShade(curRay, hit, materialIndex, i);
    }

    float totalPdf = directScat.pdf + indirectScat.pdf;

    totalAttenuation = totalAttenuation + totalIndirect * directScat.colorAttenuation * directScat.pdf / totalPdf;
    totalIndirect = totalIndirect * indirectScat.colorAttenuation * indirectScat.pdf / totalPdf;

    curRay = indirectScat.raySpecular;
  }
  
  imageStore(targetImage, ivec2(imgPosition), totalAttenuation);
}