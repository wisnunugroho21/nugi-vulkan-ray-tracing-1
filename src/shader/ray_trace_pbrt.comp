#version 460

// ------------- layout -------------

#define NSAMPLE 4
#define SHININESS 64
#define KEPSILON 0.00001

#include "core/struct.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 2) in;
layout(set = 0, binding = 0, rgba8) uniform writeonly image2D targetImage[NSAMPLE];

layout(set = 0, binding = 1) uniform readonly GlobalUbo {
  vec3 origin;
  vec3 horizontal;
  vec3 vertical;
  vec3 lowerLeftCorner;
  vec3 background;
} ubo;

layout(set = 0, binding = 2) buffer readonly ObjectSsbo {
  Object objects[100];
};

layout(set = 0, binding = 3) buffer readonly BvhSsbo {
  BvhNode bvhNodes[100];
};

layout(set = 0, binding = 4) buffer readonly materialSsbo {
  Material materials[100];
};

layout(set = 0, binding = 5) buffer readonly lightSsbo {
  Light lights[100];
};

layout(push_constant) uniform Push {
  uint randomSeed;
} push;

uvec2 imgSize = uvec2(imageSize(targetImage[0]));

uint rngStateXY =  (imgSize.x * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x) * (push.randomSeed + 1);
uint rngStateXZ =  (imgSize.x * gl_GlobalInvocationID.z + gl_GlobalInvocationID.x) * (push.randomSeed + 1);
uint rngStateYZ =  (imgSize.y * gl_GlobalInvocationID.z + gl_GlobalInvocationID.y) * (push.randomSeed + 1);

#include "core/random.glsl"
#include "core/trace.glsl"
#include "core/ggx.glsl"
#include "core/shape.glsl"
#include "core/material.glsl"
#include "core/render.glsl"

// ------------- Material -------------

ShadeRecord shade(Ray r, HitRecord hit, uint materialIndex) {
  ShadeRecord scat;
  scat.raySpecular.origin = hit.point;

  if (materials[materialIndex].metallicness >= randomFloat(0)) {
    vec3 unitViewDirection = normalize(r.direction);
    float f0 = 0.16 * (materials[materialIndex].fresnelReflect * materials[materialIndex].fresnelReflect);

    vec3[3] globalOnb = buildOnb(reflect(unitViewDirection, hit.faceNormal.normal));
    scat.raySpecular.direction = ggxGenerateRandom(globalOnb, materials[materialIndex].roughness);

    vec3 unitLightDirection = normalize(scat.raySpecular.direction);
    vec3 H = normalize(scat.raySpecular.direction - r.direction); // half vector

    float NoL = max(dot(hit.faceNormal.normal, unitLightDirection), 0.001);
    float NoV = max(dot(hit.faceNormal.normal, -1.0 * unitViewDirection), 0.001);
    float NoH = max(dot(hit.faceNormal.normal, H), 0.001);
    float VoH = max(dot(unitViewDirection, H), 0.001);

    float brdf = ggxBrdfValue(NoV, NoL, NoH, VoH, f0, materials[materialIndex].roughness);

    scat.colorAttenuation = partialIntegrand(materials[materialIndex].baseColor, brdf, NoL);
    scat.pdf = ggxPdfValue(NoH, NoL, materials[materialIndex].roughness);
  } else {
    if (randomInt(0, 1, 0) == 0) {
      int triangleRand = randomInt(0, 1, 1);
      scat.raySpecular.direction = triangleGenerateRandom(lights[triangleRand].triangle, hit.point);
    } else {
      vec3[3] globalOnb = buildOnb(hit.faceNormal.normal);
      scat.raySpecular.direction = lambertGenerateRandom(globalOnb);
    }

    vec3 unitLightDirection = normalize(scat.raySpecular.direction);
    float NoL = max(dot(hit.faceNormal.normal, unitLightDirection), 0.001);

    float brdf = lambertBrdfValue();

    scat.colorAttenuation = partialIntegrand(materials[materialIndex].baseColor, brdf, NoL);
    scat.pdf = lambertPdfValue(NoL);
  }
  
  return scat;
}

// ------------- Light -------------

RadianceRecord radiance(Ray r, HitRecord hit, uint lightIndex) {
  RadianceRecord rad;

  float sqrDistance = hit.t * hit.t * dot(r.direction, r.direction);
  float cosine = max(dot(hit.faceNormal.normal, -1.0 * normalize(r.direction)), 0.001);

  rad.colorIrradiance = cosine * areaTriangle(lights[lightIndex].triangle) / sqrDistance;
  return rad;
}

// ------------- Main -------------

void main() {
  uint imgIndex = gl_GlobalInvocationID.z;
  uvec2 imgPosition = gl_GlobalInvocationID.xy;

  uvec2 imgSize = uvec2(imageSize(targetImage[imgIndex]));

  float noiseX = randomFloat(1) * 2.0 - 1.0;
  float noiseY = randomFloat(2) * 2.0 - 1.0;

  vec2 noiseUV = vec2(noiseX, noiseY);
  vec2 uv = (imgPosition + noiseUV) / imgSize;

  Ray curRay;
  ShadeRecord scat;

  curRay.origin = ubo.origin;
  curRay.direction = ubo.lowerLeftCorner + uv.x * ubo.horizontal - uv.y * ubo.vertical - ubo.origin;
  scat.pdf = 1.0;

  vec3 lastNum = vec3(0.0);
  vec3 totalAttenuation = vec3(1.0);
  
  for(int i = 0; i < 50; i++) {
    HitRecord hittedLight = hitLightList(curRay, 0.001, 1000000.0);
    if (hittedLight.isHit) {
      if (i > 0) {
        RadianceRecord rad = radiance(curRay, hittedLight, hittedLight.objIndex);
        totalAttenuation = totalAttenuation * rad.colorIrradiance;
      }
      
      lastNum = lights[hittedLight.objIndex].color;
      break;
    }

    totalAttenuation = totalAttenuation / scat.pdf;

    HitRecord hit = hitBvh(curRay, 0.001, hittedLight.t);
    if (!hit.isHit) {
      lastNum = ubo.background;
      break;
    }

    scat = shade(curRay, hit, objects[hit.objIndex].materialIndex);

    totalAttenuation = totalAttenuation * scat.colorAttenuation;
    curRay = scat.raySpecular;
  }
  
  vec4 curColor = vec4(totalAttenuation * lastNum, 1.0);
  imageStore(targetImage[imgIndex], ivec2(imgPosition), curColor);
}