#version 460

// ------------- layout -------------

#define NSAMPLE 4
#define SHININESS 64
#define KEPSILON 0.00001

#include "core/struct.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 2) in;
layout(set = 0, binding = 0, rgba8) uniform writeonly image2D targetImage[NSAMPLE];

layout(set = 0, binding = 1) uniform readonly GlobalUbo {
  vec3 origin;
  vec3 horizontal;
  vec3 vertical;
  vec3 lowerLeftCorner;
  vec3 background;
} ubo;

layout(set = 0, binding = 2) buffer readonly ObjectSsbo {
  Object objects[100];
};

layout(set = 0, binding = 3) buffer readonly BvhSsbo {
  BvhNode bvhNodes[100];
};

layout(set = 0, binding = 4) buffer readonly materialSsbo {
  Material materials[100];
};

layout(set = 0, binding = 5) buffer readonly lightSsbo {
  Light lights[100];
};

layout(push_constant) uniform Push {
  uint randomSeed;
} push;

uvec2 imgSize = uvec2(imageSize(targetImage[0]));

uint rngStateXY =  (imgSize.x * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x) * (push.randomSeed + 1);
uint rngStateXZ =  (imgSize.x * gl_GlobalInvocationID.z + gl_GlobalInvocationID.x) * (push.randomSeed + 1);
uint rngStateYZ =  (imgSize.y * gl_GlobalInvocationID.z + gl_GlobalInvocationID.y) * (push.randomSeed + 1);

#include "core/random.glsl"
#include "core/trace.glsl"
#include "core/ggx.glsl"
#include "core/shape.glsl"
#include "core/material.glsl"
#include "core/render.glsl"

// ------------- Material -------------

ShadeRecord indirectShade(Ray r, HitRecord hit, uint materialIndex) {
  ShadeRecord scat;
  scat.raySpecular.origin = hit.point;

  if (materials[materialIndex].metallicness >= randomFloat(0)) {
    vec3 unitViewDirection = normalize(r.direction);
    float f0 = 0.16 * (materials[materialIndex].fresnelReflect * materials[materialIndex].fresnelReflect);

    vec3[3] globalOnb = buildOnb(reflect(unitViewDirection, hit.faceNormal.normal));
    scat.raySpecular.direction = ggxGenerateRandom(globalOnb, materials[materialIndex].roughness);

    vec3 unitLightDirection = normalize(scat.raySpecular.direction);
    vec3 H = normalize(scat.raySpecular.direction - r.direction); // half vector

    float NoL = max(dot(hit.faceNormal.normal, unitLightDirection), 0.001);
    float NoV = max(dot(hit.faceNormal.normal, -1.0 * unitViewDirection), 0.001);
    float NoH = max(dot(hit.faceNormal.normal, H), 0.001);
    float VoH = max(dot(unitViewDirection, H), 0.001);

    float brdf = ggxBrdfValue(NoV, NoL, NoH, VoH, f0, materials[materialIndex].roughness);
    float pdf = ggxPdfValue(NoH, NoL, materials[materialIndex].roughness);

    scat.colorAttenuation = integrandOverHemisphere(materials[materialIndex].baseColor, brdf, NoL, pdf);
    scat.pdf = pdf;
  } else {
    vec3[3] globalOnb = buildOnb(hit.faceNormal.normal);
    scat.raySpecular.direction = lambertGenerateRandom(globalOnb);

    vec3 unitLightDirection = normalize(scat.raySpecular.direction);
    float NoL = max(dot(hit.faceNormal.normal, unitLightDirection), 0.001);

    float brdf = lambertBrdfValue();
    float pdf = lambertPdfValue(NoL);

    scat.colorAttenuation = integrandOverHemisphere(materials[materialIndex].baseColor, brdf, NoL, pdf);
    scat.pdf = pdf;
  }
  
  return scat;
}

ShadeRecord directShade(HitRecord hit) {
  ShadeRecord scat;
  scat.colorAttenuation = vec3(0.0);
  scat.pdf = 1.0;

  Ray shadowRay;
  shadowRay.origin = hit.point;

  int triangleRand = randomInt(0, 1, 1);
  shadowRay.direction = triangleGenerateRandom(lights[triangleRand].triangle, hit.point);

  HitRecord hittedLight = hitLightList(shadowRay, 0.001, 1000000.0);
  if (!hittedLight.isHit) return scat;

  vec3 unitLightDirection = normalize(shadowRay.direction);

  float NoL = max(dot(hit.faceNormal.normal, unitLightDirection), 0.001);
  float NloL = max(dot(hittedLight.faceNormal.normal, -1.0 * unitLightDirection), 0.001);

  float sqrDistance = hittedLight.t * hittedLight.t * dot(shadowRay.direction, shadowRay.direction);
  float area = areaTriangle(lights[hittedLight.objIndex].triangle);
  float brdf = lambertBrdfValue();

  scat.colorAttenuation = integrandOverArea(lights[hittedLight.objIndex].color, brdf, NoL, NloL, sqrDistance, area);
  scat.pdf = radiance(shadowRay, hittedLight, hittedLight.objIndex);

  return scat;
}

// ------------- Main -------------

void main() {
  uvec2 imgPosition = gl_GlobalInvocationID.xy;
  uint imgIndex = gl_GlobalInvocationID.z;

  uvec2 imgSize = uvec2(imageSize(targetImage[imgIndex]));

  float noiseX = randomFloat(1) * 2.0 - 1.0;
  float noiseY = randomFloat(2) * 2.0 - 1.0;

  vec2 noiseUV = vec2(noiseX, noiseY);
  vec2 uv = (imgPosition + noiseUV) / imgSize;

  vec3 totalAttenuation = vec3(1.0);
  Ray curRay;

  curRay.origin = ubo.origin;
  curRay.direction = ubo.lowerLeftCorner + uv.x * ubo.horizontal - uv.y * ubo.vertical - ubo.origin;
  
  for(int i = 0; i < 50; i++) {
    HitRecord hittedLight = hitLightList(curRay, 0.001, 1000000.0);
    if (hittedLight.isHit) {
      totalAttenuation = totalAttenuation * lights[hittedLight.objIndex].color;
      break;
    }

    HitRecord hit = hitBvh(curRay, 0.001, hittedLight.t);
    if (!hit.isHit) {
      totalAttenuation = totalAttenuation * ubo.background;
      break;
    }

    ShadeRecord indirectScat = indirectShade(curRay, hit, objects[hit.objIndex].materialIndex);
    ShadeRecord directScat = directShade(hit);

    float totalPdf = indirectScat.pdf + directScat.pdf;

    totalAttenuation = totalAttenuation * (indirectScat.pdf / totalPdf * indirectScat.colorAttenuation + directScat.pdf / totalPdf * directScat.colorAttenuation);
    curRay = indirectScat.raySpecular;
  }
  
  vec4 curColor = vec4(totalAttenuation, 1.0);
  imageStore(targetImage[imgIndex], ivec2(imgPosition), curColor);
}