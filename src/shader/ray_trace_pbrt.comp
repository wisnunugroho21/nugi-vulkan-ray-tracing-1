#version 460

// ------------- layout -------------

#define NSAMPLE 4
#define SHININESS 64
#define KEPSILON 0.00001

#include "core/struct.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 2) in;
layout(set = 0, binding = 0, rgba8) uniform writeonly image2D targetImage[NSAMPLE];

layout(set = 0, binding = 1) uniform readonly GlobalUbo {
  vec3 origin;
  vec3 horizontal;
  vec3 vertical;
  vec3 lowerLeftCorner;
  vec3 background;
} ubo;

layout(set = 0, binding = 2) buffer readonly ObjectSsbo {
  Object objects[100];
};

layout(set = 0, binding = 3) buffer readonly BvhSsbo {
  BvhNode bvhNodes[100];
};

layout(set = 0, binding = 4) buffer readonly materialSsbo {
  Material materials[100];
};

layout(set = 0, binding = 5) buffer readonly lightSsbo {
  Light lights[100];
};

layout(push_constant) uniform Push {
  uint randomSeed;
} push;

uvec2 imgSize = uvec2(imageSize(targetImage[0]));

uint rngStateXY =  (imgSize.x * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x) * (push.randomSeed + 1);
uint rngStateXZ =  (imgSize.x * gl_GlobalInvocationID.z + gl_GlobalInvocationID.x) * (push.randomSeed + 1);
uint rngStateYZ =  (imgSize.y * gl_GlobalInvocationID.z + gl_GlobalInvocationID.y) * (push.randomSeed + 1);

#include "core/random.glsl"
#include "core/trace.glsl"
#include "core/ggx.glsl"
#include "core/shape.glsl"
#include "core/material.glsl"
#include "core/render.glsl"

// ------------- Material -------------

ShadeRecord shade(Ray r, HitRecord hit, uint materialIndex) {
  ShadeRecord scat;
  scat.raySpecular.origin = hit.point;

  if (materials[materialIndex].metallicness >= randomFloat(0)) {
    vec3 unitViewDirection = normalize(r.direction);
    float f0 = 0.16 * (materials[materialIndex].fresnelReflect * materials[materialIndex].fresnelReflect);

    vec3[3] globalOnb = buildOnb(reflect(unitViewDirection, hit.faceNormal.normal));
    scat.raySpecular.direction = ggxGenerateRandom(globalOnb, materials[materialIndex].roughness);

    vec3 unitLightDirection = normalize(scat.raySpecular.direction);
    vec3 H = normalize(scat.raySpecular.direction - r.direction); // half vector

    float NoL = clamp(dot(hit.faceNormal.normal, unitLightDirection), 0.001, 1.0);
    float NoV = clamp(dot(hit.faceNormal.normal, -1.0 * unitViewDirection), 0.001, 1.0);
    float NoH = clamp(dot(hit.faceNormal.normal, H), 0.001, 1.0);
    float VoH = clamp(dot(unitViewDirection, H), 0.001, 1.0);

    float brdf = ggxBrdfValue(NoV, NoL, NoH, VoH, f0, materials[materialIndex].roughness);

    scat.colorAttenuation = partialIntegrand(materials[materialIndex].baseColor, brdf, NoL);
    scat.pdf = ggxPdfValue(NoH, NoL, materials[materialIndex].roughness);
  } else {
    if (randomInt(0, 2, 0) == 0) {
      int triangleRand = randomInt(0, 1, 1);
      scat.raySpecular.direction = triangleGenerateRandom(lights[triangleRand].triangle, hit.point);
    } else {
      vec3[3] globalOnb = buildOnb(hit.faceNormal.normal);
      scat.raySpecular.direction = lambertGenerateRandom(globalOnb);
    }

    vec3 unitLightDirection = normalize(scat.raySpecular.direction);
    float NoL = clamp(dot(hit.faceNormal.normal, unitLightDirection), 0.001, 1.0);

    float brdf = lambertBrdfValue();

    scat.colorAttenuation = partialIntegrand(materials[materialIndex].baseColor, brdf, NoL);
    scat.pdf = lambertPdfValue(hit.faceNormal.normal, scat.raySpecular.direction);
  }
  
  return scat;
}

// ------------- Light -------------

RadianceRecord radiance(Ray r, HitRecord hit, uint lightIndex) {
  RadianceRecord rad;

  float sqrDistance = hit.t * hit.t * dot(r.direction, r.direction);
  float cosine = clamp(dot(hit.faceNormal.normal, -1.0 * normalize(r.direction)), 0.0, 1.0);

  rad.colorIrradiance = lights[lightIndex].color * cosine * areaTriangle(lights[lightIndex].triangle) / sqrDistance;
  return rad;
}

// ------------- Main -------------

void main() {
  uint imgIndex = gl_GlobalInvocationID.z;
  uvec2 imgPosition = gl_GlobalInvocationID.xy;

  uvec2 imgSize = uvec2(imageSize(targetImage[imgIndex]));

  float noiseX = randomFloat(1) * 2.0 - 1.0;
  float noiseY = randomFloat(2) * 2.0 - 1.0;

  vec2 noiseUV = vec2(noiseX, noiseY);
  vec2 uv = (imgPosition + noiseUV) / imgSize;

  Ray curRay;
  ShadeRecord scat;

  curRay.origin = ubo.origin;
  curRay.direction = ubo.lowerLeftCorner + uv.x * ubo.horizontal - uv.y * ubo.vertical - ubo.origin;

  vec4 lastNum = vec4(0.0, 0.0, 0.0, 0.0);
  mat4 rayTransform = mat4(
    1.0, 0.0, 0.0, 0.0,
    0.0, 1.0, 0.0, 0.0,
    0.0, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.0, 1.0
  );
  
  for(int i = 0; i < 50; i++) {
    HitRecord hit = hitBvh(curRay, 0.001, 1000000.0);
    if (!hit.isHit) {
      lastNum = vec4(ubo.background, 1.0);
      break;
    }

    HitRecord hittedLight = hitLightList(curRay, 0.001, hit.t);
    if (hittedLight.isHit) {
      RadianceRecord rad = radiance(curRay, hittedLight, hittedLight.objIndex);
      lastNum = vec4(rad.colorIrradiance, 1.0);

      break;
    }

    if (i > 0) rayTransform = rayTransform / scat.pdf;
    scat = shade(curRay, hit, objects[hit.objIndex].materialIndex);

    mat4 emitTransf = mat4(
      1.0, 0.0, 0.0, scat.colorEmitted.x,
      0.0, 1.0, 0.0, scat.colorEmitted.y,
      0.0, 0.0, 1.0, scat.colorEmitted.z,
      0.0, 0.0, 0.0, 1.0
    );

    mat4 attentTransf = mat4(
      scat.colorAttenuation.x, 0.0, 0.0, 0.0,
      0.0, scat.colorAttenuation.y, 0.0, 0.0,
      0.0, 0.0, scat.colorAttenuation.z, 0.0,
      0.0, 0.0, 0.0, 1.0
    );

    rayTransform = emitTransf * attentTransf * rayTransform;
    curRay = scat.raySpecular;
  }
  
  vec4 curColor = rayTransform * lastNum;
  imageStore(targetImage[imgIndex], ivec2(imgPosition), curColor);
}