#version 460

// ------------- layout -------------

#define NSAMPLE 4
#define SHININESS 64
#define KEPSILON 0.00001

#include "core/struct.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 2) in;
layout(set = 0, binding = 0, rgba8) uniform writeonly image2D targetImage[NSAMPLE];

layout(set = 0, binding = 1) uniform readonly GlobalUbo {
  vec3 origin;
  vec3 horizontal;
  vec3 vertical;
  vec3 lowerLeftCorner;
  vec3 background;
} ubo;

layout(set = 0, binding = 2) buffer readonly ObjectSsbo {
  Object objects[100];
};

layout(set = 0, binding = 3) buffer readonly BvhSsbo {
  BvhNode bvhNodes[100];
};

layout(set = 0, binding = 4) buffer readonly materialSsbo {
  Material materials[100];
};

layout(set = 0, binding = 5) buffer readonly lightSsbo {
  Light lights[100];
};

layout(push_constant) uniform Push {
  uint randomSeed;
} push;

uvec2 imgSize = uvec2(imageSize(targetImage[0]));

uint rngStateXY =  (imgSize.x * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x) * (push.randomSeed + 1);
uint rngStateXZ =  (imgSize.x * gl_GlobalInvocationID.z + gl_GlobalInvocationID.x) * (push.randomSeed + 1);
uint rngStateYZ =  (imgSize.y * gl_GlobalInvocationID.z + gl_GlobalInvocationID.y) * (push.randomSeed + 1);

#include "core/random.glsl"
#include "core/trace.glsl"
#include "core/ggx.glsl"
#include "core/shape.glsl"
#include "core/material.glsl"
#include "core/render.glsl"

// ------------- Material -------------

ShadeRecord indirectShade(Ray r, HitRecord hit, uint materialIndex) {
  ShadeRecord scat;
  scat.raySpecular.origin = hit.point;

  if (materials[materialIndex].metallicness >= randomFloat(0)) {
    vec3 unitViewDirection = normalize(r.direction);
    float f0 = 0.16 * (materials[materialIndex].fresnelReflect * materials[materialIndex].fresnelReflect);

    vec3[3] globalOnb = buildOnb(reflect(unitViewDirection, hit.faceNormal.normal));
    scat.raySpecular.direction = ggxGenerateRandom(globalOnb, materials[materialIndex].roughness);

    vec3 unitLightDirection = normalize(scat.raySpecular.direction);
    vec3 H = normalize(scat.raySpecular.direction - r.direction); // half vector

    float NoL = max(dot(hit.faceNormal.normal, unitLightDirection), 0.001);
    float NoV = max(dot(hit.faceNormal.normal, -1.0 * unitViewDirection), 0.001);
    float NoH = max(dot(hit.faceNormal.normal, H), 0.001);
    float VoH = max(dot(unitViewDirection, H), 0.001);

    float brdf = ggxBrdfValue(NoV, NoL, NoH, VoH, f0, materials[materialIndex].roughness);
    float pdf = ggxPdfValue(NoH, NoL, materials[materialIndex].roughness);

    scat.colorAttenuation = integrandOverHemisphere(materials[materialIndex].baseColor, brdf, NoL, pdf);
  } else {
    vec3[3] globalOnb = buildOnb(hit.faceNormal.normal);
    scat.raySpecular.direction = lambertGenerateRandom(globalOnb);

    vec3 unitLightDirection = normalize(scat.raySpecular.direction);
    float NoL = max(dot(hit.faceNormal.normal, unitLightDirection), 0.001);

    float brdf = lambertBrdfValue();
    float pdf = lambertPdfValue(NoL);

    scat.colorAttenuation = integrandOverHemisphere(materials[materialIndex].baseColor, brdf, NoL, pdf);
  }
  
  return scat;
}

ShadeRecord directShade(Ray r, HitRecord hit, uint materialIndex) {
  ShadeRecord scat;
  scat.colorAttenuation = vec3(0.0);

  Ray shadowRay;
  shadowRay.origin = hit.point;

  for (int i = 0; i < 2; i++) {
    shadowRay.direction = triangleGenerateRandom(lights[i].triangle, hit.point);
    vec3 unitLightDirection = normalize(shadowRay.direction);

    HitRecord hittedLight = hitLightList(shadowRay, 0.001, 1000000.0);
    if (!hittedLight.isHit) continue;

    if (materials[materialIndex].metallicness >= randomFloat(0)) {
      vec3 unitViewDirection = normalize(r.direction);
      vec3 H = normalize(shadowRay.direction - r.direction); // half vector

      float f0 = 0.16 * (materials[materialIndex].fresnelReflect * materials[materialIndex].fresnelReflect);

      float NoL = max(dot(hit.faceNormal.normal, unitLightDirection), 0.001);
      float NoV = max(dot(hit.faceNormal.normal, -1.0 * unitViewDirection), 0.001);
      float NoH = max(dot(hit.faceNormal.normal, H), 0.001);
      float VoH = max(dot(unitViewDirection, H), 0.001);
      float NloL = max(dot(hittedLight.faceNormal.normal, -1.0 * unitLightDirection), 0.001);

      float brdf = ggxBrdfValue(NoV, NoL, NoH, VoH, f0, materials[materialIndex].roughness);
      float sqrDistance = hittedLight.t * hittedLight.t * dot(shadowRay.direction, shadowRay.direction);
      float area = areaTriangle(lights[hittedLight.objIndex].triangle);

      scat.colorAttenuation += integrandOverArea(lights[hittedLight.objIndex].color, brdf, NoL, NloL, sqrDistance, area);
    } else {
      float NoL = max(dot(hit.faceNormal.normal, unitLightDirection), 0.001);
      float NloL = max(dot(hittedLight.faceNormal.normal, -1.0 * unitLightDirection), 0.001);

      float sqrDistance = hittedLight.t * hittedLight.t * dot(shadowRay.direction, shadowRay.direction);
      float area = areaTriangle(lights[hittedLight.objIndex].triangle);
      float brdf = lambertBrdfValue();

      scat.colorAttenuation += integrandOverArea(lights[hittedLight.objIndex].color, brdf, NoL, NloL, sqrDistance, area);
    }
  }

  return scat;
}

// ------------- Main -------------

void main() {
  uvec2 imgPosition = gl_GlobalInvocationID.xy;
  uint imgIndex = gl_GlobalInvocationID.z;

  uvec2 imgSize = uvec2(imageSize(targetImage[imgIndex]));

  float noiseX = randomFloat(1) * 2.0 - 1.0;
  float noiseY = randomFloat(2) * 2.0 - 1.0;

  vec2 noiseUV = vec2(noiseX, noiseY);
  vec2 uv = (imgPosition + noiseUV) / imgSize;
  
  vec4 totalAttenuation = vec4(1.0);
  Ray curRay;  

  curRay.origin = ubo.origin;
  curRay.direction = ubo.lowerLeftCorner + uv.x * ubo.horizontal - uv.y * ubo.vertical - ubo.origin;
  
  for(int i = 0; i < 4; i++) {
    HitRecord hit = hitBvh(curRay, 0.001, 1000000.0);
    if (!hit.isHit) {
      totalAttenuation = totalAttenuation * vec4(ubo.background, 1.0);
      break;
    }

    HitRecord hittedLight = hitLightList(curRay, 0.001, hit.t);
    if (hittedLight.isHit) {
      break;
    }

    ShadeRecord indirectScat = indirectShade(curRay, hit, objects[hit.objIndex].materialIndex);
    ShadeRecord directScat = directShade(curRay, hit, objects[hit.objIndex].materialIndex);

    mat4 directTransf = mat4(
      1.0, 0.0, 0.0, directScat.colorAttenuation.x,
      0.0, 1.0, 0.0, directScat.colorAttenuation.y,
      0.0, 0.0, 1.0, directScat.colorAttenuation.z,
      0.0, 0.0, 0.0, 1.0
    );

    mat4 indirectTransf = mat4(
      indirectScat.colorAttenuation.x, 0.0, 0.0, 0.0,
      0.0, indirectScat.colorAttenuation.y, 0.0, 0.0,
      0.0, 0.0, indirectScat.colorAttenuation.z, 0.0,
      0.0, 0.0, 0.0, 1.0
    );

    totalAttenuation = directTransf * indirectTransf * totalAttenuation;
    curRay = indirectScat.raySpecular;
  }
  
  vec4 curColor = totalAttenuation;
  imageStore(targetImage[imgIndex], ivec2(imgPosition), curColor);
}