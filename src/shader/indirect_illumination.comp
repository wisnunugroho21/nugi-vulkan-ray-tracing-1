#version 460

// ------------- layout -------------

#define NSAMPLE 4
#define SHININESS 64
#define KEPSILON 0.00001

#include "helper/struct.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 1) buffer readonly GlobalLight {
	PointLight pointLights[100];
	uint numLight;
} globalLight;

layout(set = 0, binding = 2) buffer readonly GlobalModel {
  Model models[100];
  uint numModel;
} globalModel;

layout(set = 0, binding = 3) buffer readonly GlobalBvh {
  BvhNode bvhNodes[100];
  uint numNode;
} globalBvh;

layout(set = 0, binding = 4) buffer readonly GlobalMaterial {
  Material materials[100];
};

layout(set = 0, binding = 5) uniform readonly GlobalTransform {
  Transform transform[100];
};

layout(set = 0, binding = 6) uniform readonly RayTraceUbo {
  vec3 origin;
  vec3 horizontal;
  vec3 vertical;
  vec3 lowerLeftCorner;
  vec3 background;
} ubo;

layout(set = 1, binding = 0, rgba8) uniform readonly image2D positionResource;
layout(set = 1, binding = 1, rgba8) uniform readonly image2D albedoResource;
layout(set = 1, binding = 2, rgba8) uniform readonly image2D normalResource;
layout(set = 1, binding = 3, rgba8) uniform readonly image2D materialResource;

layout(set = 2, binding = 2, rgba8) uniform writeonly image2D rayTraceImage;

layout(push_constant) uniform Push {
  uint randomSeed;
} push;

// ------------- function ------------- 

uvec2 imgSize = uvec2(imageSize(rayTraceImage));

uint rngStateXY = (imgSize.x * uint(gl_GlobalInvocationID.y) + uint(gl_GlobalInvocationID.x)) * (push.randomSeed + 1);
uint rngStateYX = (imgSize.y * uint(gl_GlobalInvocationID.x) + uint(gl_GlobalInvocationID.y)) * (push.randomSeed + 1);

#include "helper/random.glsl"
#include "helper/trace.glsl"
#include "helper/brdf.glsl"

// ------------- Material -------------

ShadeRecord shade(Ray r, HitRecord hit, uint materialIndex) {
  ShadeRecord scat;
  scat.colorEmitted = vec3(0.0, 0.0, 0.0);

  float f0 = 0.16 * (materials[materialIndex].fresnelReflect * materials[materialIndex].fresnelReflect); // F0 for dielectics in range [0.0, 0.16].  default FO is (0.16 * 0.5^2) = 0.04
  vec3 unitViewDirection = normalize(r.direction);
  vec3 reflected = reflect(unitViewDirection, hit.faceNormal.normal);

  scat.raySpecular.origin = hit.point;
  float rand = randomFloat(0);

  if (materials[materialIndex].metallicness >= rand) {
    vec3[3] globalOnb = buildOnb(reflected);
    scat.raySpecular.direction = ggxGenerateRandom(globalOnb, materials[materialIndex].roughness);
  } else {
    vec3[3] globalOnb = buildOnb(hit.faceNormal.normal);
    int chooseRandom = randomInt(0, 1, 0);

    switch(chooseRandom) {
      case 0: scat.raySpecular.direction = sphereListGenerateRandom(hit.point); break;
      case 1: scat.raySpecular.direction = cosineGenerateRandom(globalOnb); break;
    }
  }
  
  vec3 unitLightDirection = normalize(scat.raySpecular.direction);
  vec3 HalAngle = normalize(scat.raySpecular.direction - r.direction); // half vector

  float NoV = clamp(dot(hit.faceNormal.normal, -1.0 * unitViewDirection), 0.0, 1.0);
  float NoL = clamp(dot(hit.faceNormal.normal, unitLightDirection), 0.0, 1.0);
  float NoH = clamp(dot(hit.faceNormal.normal, HalAngle), 0.0, 1.0);
  float VoH = clamp(dot(unitViewDirection, HalAngle), 0.0, 1.0);

  // specular microfacet (cook-torrance) BRDF
  float F = fresnelSchlick(VoH, f0);
  float D = D_GGX(NoH, materials[materialIndex].roughness);
  float G = G_Smith(NoV, NoL, materials[materialIndex].roughness);
  float spec = (F * D * G) / (4.0 * NoV * NoL);
  
  // diffuse
  float diff = 1.0 / pi;

  float specPdf = ggxPdfValue(NoH, NoL, materials[materialIndex].roughness);
  float diffPdf = 0.5 * (cosinePdfValue(hit.faceNormal.normal, scat.raySpecular.direction) + sphereListPdfValue(scat.raySpecular));

  float pdfVal = mix(diffPdf, specPdf, materials[materialIndex].metallicness);
  float totalBrdf = mix(diff, spec, materials[materialIndex].metallicness);

  scat.colorAttenuation = materials[materialIndex].color * totalBrdf * NoL / pdfVal;
  return scat;
}

// ------------- Main -------------

void main() {
  uvec2 imgPosition = gl_GlobalInvocationID.xy;

  vec3 fragPosWorld = imageLoad(positionResource, ivec2(gl_GlobalInvocationID.xy)).xyz;
  vec3 fragNormalWorld = imageLoad(normalResource, ivec2(gl_GlobalInvocationID.xy)).xyz;

  vec3[3] normalOrthogonal = buildOnb(fragNormalWorld);

  Ray curRay;
  curRay.origin = fragPosWorld;
  curRay.direction = cosineGenerateRandom(normalOrthogonal);

  vec4 lastNum = vec4(0.0, 0.0, 0.0, 0.0);
  mat4 rayTransform = mat4(
    1.0, 0.0, 0.0, 0.0,
    0.0, 1.0, 0.0, 0.0,
    0.0, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.0, 1.0
  );
  
  for(int i = 0; i < 50; i++) {
    HitRecord hit = hitBvh(curRay, 0.001, 1000000.0);
    if (!hit.isHit) {
      lastNum = vec4(ubo.background, 1.0);
      break;
    }

    HitRecord hittedLight = hitLightList(curRay, 0.001, hit.t);
    if (hittedLight.isHit) {
      lastNum = vec4(globalLight.pointLights[hittedLight.objIndex].color, 1.0);
      break;
    }

    ShadeRecord scat = shade(curRay, hit, globalModel.models[hit.objIndex].materialIndex);

    mat4 emitTransf = mat4(
      1.0, 0.0, 0.0, scat.colorEmitted.x,
      0.0, 1.0, 0.0, scat.colorEmitted.y,
      0.0, 0.0, 1.0, scat.colorEmitted.z,
      0.0, 0.0, 0.0, 1.0
    );

    mat4 attentTransf = mat4(
      scat.colorAttenuation.x, 0.0, 0.0, 0.0,
      0.0, scat.colorAttenuation.y, 0.0, 0.0,
      0.0, 0.0, scat.colorAttenuation.z, 0.0,
      0.0, 0.0, 0.0, 1.0
    );

    rayTransform = emitTransf * attentTransf * rayTransform;
    curRay = scat.raySpecular;
  }
  
  vec4 curColor = rayTransform * lastNum;
  imageStore(rayTraceImage, ivec2(imgPosition), curColor);
}